<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Κβαντική Τρίλιζα</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f7f9fb;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin: 20px 0;
            aspect-ratio: 1 / 1; /* Makes the grid square */
        }

        .cell {
            background-color: #e8ecf1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s, transform 0.1s;
            height: 100%;
            min-height: 80px; /* Minimum height for mobile */
            user-select: none;
            text-align: center;
            padding: 5px;
        }

        .cell:hover:not(.definite):not(.selected-cell) {
            background-color: #dce0e6;
        }

        .cell.selected-cell {
            background-color: #6366f1;
            color: white;
            transform: scale(1.05);
        }

        .cell.definite {
            cursor: default;
            background-color: #3b82f6; /* Blue for definite */
            color: white;
            font-size: 3rem;
        }
        
        /* Style for quantum moves inside the cell */
        .q-move-text {
            font-size: 0.85rem;
            font-weight: 400;
            color: #6b7280;
            line-height: 1.2;
            margin-top: 2px;
        }

        .definite .q-move-text {
            display: none;
        }
        
        .x-player { color: #ef4444; } /* Red */
        .o-player { color: #10b981; } /* Green */
        .collapse-mode { background-color: #fca5a5; } /* Light red for collapse */

        /* Style for buttons and messages */
        .btn-primary {
            background-color: #10b981;
            color: white;
            padding: 10px 20px;
            border-radius: 0.5rem;
            font-weight: 700;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: #059669;
        }

        .message-box {
            min-height: 60px;
        }
        
        /* Collapse buttons */
        .collapse-option {
            background-color: #fef3c7;
            border: 2px solid #f59e0b;
            color: #f59e0b;
            font-weight: 600;
            padding: 8px 15px;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .collapse-option:hover {
            background-color: #fffbeb;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-4 text-gray-800">Κβαντική Τρίλιζα</h1>
        <p class="text-center text-gray-600 mb-6">Στόχος: Δημιουργία τριών οριστικών X ή O στη σειρά μετά από μια κατάρρευση.</p>

        <div id="message" class="message-box text-center p-3 mb-4 rounded-lg font-bold text-lg"></div>

        <div id="board" class="board border-4 border-gray-400 rounded-lg">
            </div>

        <div class="flex justify-center mt-6">
            <button id="reset-btn" class="btn-primary">
                Επανεκκίνηση Παιχνιδιού
            </button>
        </div>
        
        <div id="collapse-options" class="flex flex-wrap justify-center gap-2 mt-4">
            </div>
    </div>

    <script type="text/javascript">
        // Global game variables
        let gameActive = true;
        let currentPlayer = 'X';
        let moveStage = 1; // 1: Select 1st cell, 2: Select 2nd cell, 3: Collapse
        let firstCellIndex = null;
        let moveCounter = 1;
        
        // Board states:
        // definite: The definite mark ('X', 'O', or null)
        // superposition: An array with the IDs of the quantum moves involved in this cell.
        let boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));

        // Records all quantum moves
        // Example: { id: 1, player: 'X', cells: [0, 4] }
        let superpositionMoves = []; 

        const winningCombos = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Horizontal
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Vertical
            [0, 4, 8], [2, 4, 6]            // Diagonal
        ];

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const resetBtn = document.getElementById('reset-btn');
        const collapseOptionsElement = document.getElementById('collapse-options');

        // --- Helper Functions ---

        /**
         * Updates the game status message.
         */
        function updateMessage(text, colorClass = 'text-gray-800', backgroundClass = 'bg-gray-200') {
            messageElement.textContent = text;
            messageElement.className = `message-box text-center p-3 mb-4 rounded-lg font-bold text-lg ${colorClass} ${backgroundClass}`;
        }

        /**
         * Renders the board state to the DOM.
         */
        function renderBoard() {
            boardElement.innerHTML = '';
            boardState.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.dataset.index = index;

                if (cell.definite) {
                    // Definite state
                    cellElement.classList.add('definite');
                    cellElement.textContent = cell.definite;
                    cellElement.classList.add(cell.definite === 'X' ? 'x-player' : 'o-player');
                } else {
                    // Superposition
                    cellElement.addEventListener('click', handleCellClick);
                    
                    // Display the involved quantum moves
                    const movesText = cell.superposition.map(moveId => {
                        const move = superpositionMoves.find(m => m.id === moveId);
                        if (!move) return '';
                        
                        // Greek translation in display
                        const playerMark = move.player === 'X' ? 'Χ' : 'Ο';
                        return `<span class="${move.player === 'X' ? 'x-player' : 'o-player'}">${playerMark}<sub>${moveId}</sub></span>`;
                    }).join(', ');

                    cellElement.innerHTML = `<span class="text-2xl">&nbsp;</span><div class="q-move-text">${movesText}</div>`;

                    // Display selected cell during stage 1
                    if (moveStage === 2 && index === firstCellIndex) {
                        cellElement.classList.add('selected-cell');
                    }
                }

                boardElement.appendChild(cellElement);
            });
        }
        
        /**
         * Checks for a win in the definite board state.
         */
        function checkForWin() {
            for (const [a, b, c] of winningCombos) {
                const valA = boardState[a].definite;
                const valB = boardState[b].definite;
                const valC = boardState[c].definite;

                if (valA && valA === valB && valA === valC) {
                    gameActive = false;
                    const winnerMark = valA === 'X' ? 'Χ' : 'Ο'; // Greek mark for display
                    updateMessage(`Νικητής: Παίκτης ${winnerMark}!`, 'text-white', valA === 'X' ? 'bg-red-600' : 'bg-green-600');
                    return true;
                }
            }

            // Check for tie (if all cells are definite)
            const allDefinite = boardState.every(cell => cell.definite !== null);
            if (allDefinite) {
                gameActive = false;
                updateMessage("Ισοπαλία! Ο πίνακας έχει καταρρεύσει πλήρως.", 'text-gray-800', 'bg-yellow-400');
                return true;
            }

            return false;
        }

        /**
         * Δημιουργεί τον γράφο εμπλοκής μόνο με τις ενεργές κινήσεις υπέρθεσης.
         * (Διορθώθηκε για να διασφαλίζεται ότι μόνο οι πλήρως ενεργές ακμές περιλαμβάνονται)
         */
        function createEntanglementGraph() {
            const nodes = 9;
            const adj = Array.from({ length: nodes }, () => []);
            
            for (const move of superpositionMoves) {
                const [u, v] = move.cells;

                // Μια κίνηση θεωρείται ενεργή ακμή εμπλοκής μόνο αν υπάρχει
                // στη superposition και των δύο κελιών.
                const isMoveActive = boardState[u].superposition.includes(move.id) && boardState[v].superposition.includes(move.id);

                if (isMoveActive) {
                    adj[u].push({ neighbor: v, moveId: move.id });
                    adj[v].push({ neighbor: u, moveId: move.id });
                }
            }
            return { adj };
        }
        
        /**
         * Detects a cycle (loop) in the superposition graph using DFS.
         */
        function findCycle(newMove) {
            const { adj } = createEntanglementGraph();
            const nodes = 9;
            const visited = new Array(nodes).fill(false);
            const path = []; 
            
            // DFS utility function
            function dfs(u, parentNode) { 
                visited[u] = true;
                path.push(u);

                for (const { neighbor: v, moveId } of adj[u]) {
                    // Ignore the edge to the parent node
                    if (v === parentNode) continue; 
                    
                    if (visited[v]) {
                        // Cycle found: v is already visited and is not the direct parent
                        const startIndex = path.indexOf(v);
                        if (startIndex !== -1) {
                            let cycleMoves = [];
                            
                            // 1. Traverse the path from v up to u to find the intermediate move IDs
                            for (let i = startIndex; i < path.length; i++) {
                                const cell1 = path[i];
                                const cell2 = (i === path.length - 1) ? u : path[i + 1];

                                // Find the move ID that connects cell1 and cell2 AND is in the adjacency list
                                const edge = adj[cell1].find(e => e.neighbor === cell2);
                                
                                if (edge && !cycleMoves.includes(edge.moveId)) {
                                    cycleMoves.push(edge.moveId);
                                }
                            }
                            
                            // 2. Add the move that closed the cycle (u to v)
                            const closingEdge = adj[u].find(e => e.neighbor === v);

                            if (closingEdge && !cycleMoves.includes(closingEdge.moveId)) {
                                cycleMoves.push(closingEdge.moveId);
                            }
                            
                            // Check if the cycle is valid (should always be if found via DFS on the active graph)
                            if (cycleMoves.length > 0) return cycleMoves;
                        }
                    } else {
                        const result = dfs(v, u); // u is the parent node for v
                        if (result) return result;
                    }
                }

                path.pop(); 
                return null;
            }

            // Start DFS from all nodes
            for (let i = 0; i < nodes; i++) {
                if (!visited[i] && boardState[i].definite === null) { 
                    const result = dfs(i, -1); 
                    if (result) return result;
                }
            }
            
            return null;
        }

        /**
         * Starts the collapse phase.
         */
        function startCollapsePhase(cycleMoveIds) {
            gameActive = true; 
            moveStage = 3; 
            boardElement.classList.add('collapse-mode');
            
            const cycleMoves = superpositionMoves.filter(m => cycleMoveIds.includes(m.id));
            const playerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
            
            updateMessage(
                `Παίκτης ${playerMark}: Επιλέξτε πού θα καταρρεύσει μια κίνηση του κύκλου.`, 
                'text-red-700', 
                'bg-red-200'
            );

            collapseOptionsElement.innerHTML = '';
            
            // Display options for all moves in the cycle
            cycleMoves.forEach(move => {
                const [cellA, cellB] = move.cells;
                const movePlayerMark = move.player === 'X' ? 'Χ' : 'Ο';
                
                // Εμφάνισε επιλογή μόνο αν το κελί ΔΕΝ είναι definite ΚΑΙ περιέχει ακόμα την κίνηση.
                
                // Επιλογή κατάρρευσης στο Κελί Α
                if (boardState[cellA].definite === null && boardState[cellA].superposition.includes(move.id)) {
                    const btnA = document.createElement('button');
                    btnA.classList.add('collapse-option');
                    btnA.textContent = `${movePlayerMark}${move.id} → Κελί ${cellA + 1}`;
                    btnA.onclick = () => resolveCollapse(move.id, cellA);
                    collapseOptionsElement.appendChild(btnA);
                }

                // Επιλογή κατάρρευσης στο Κελί Β
                if (boardState[cellB].
