<!DOCTYPE html>


if (moveStage === 1) {
firstCellIndex = idx;
moveStage = 2;
updateMessage(`Παίκτης ${currentPlayer}: Επιλέξτε 2ο κελί.`);
renderBoard();
return;
}


if (idx === firstCellIndex) {
updateMessage("Πρέπει να διαλέξετε διαφορετικό κελί.");
return;
}


// create and register the new superposition move (use post-increment to ensure unique id)
const newId = moveCounter++;
const newMove = {
id: newId,
player: currentPlayer,
cells: [firstCellIndex, idx]
};


superpositionMoves.push(newMove);
boardState[firstCellIndex].superposition.push(newMove.id);
boardState[idx].superposition.push(newMove.id);


// Find cycle that includes the newly added move (if any)
const cycle = findCycle(newMove);
if (cycle && cycle.length) {
startCollapsePhase(cycle);
} else {
currentPlayer = currentPlayer === "X" ? "O" : "X";
moveStage = 1;
firstCellIndex = null;
updateMessage(`Παίκτης ${currentPlayer}: Κάντε την 1η επιλογή σας.`);
}
renderBoard();
}


function resetGame() {
gameActive = true;
currentPlayer = "X";
moveStage = 1;
firstCellIndex = null;
moveCounter = 1;
boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));
superpositionMoves = [];
collapseOptionsElement.innerHTML = "";
boardElement.classList.remove("collapse-mode");
updateMessage(`Παίκτης X: Κάντε την 1η επιλογή σας.`);
renderBoard();
}


document.addEventListener("DOMContentLoaded", () => {
resetBtn.addEventListener("click", resetGame);
resetGame();
});
</script>
</body>
</html>
