<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Κβαντική Τρίλιζα</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f7f9fb;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin: 20px 0;
            aspect-ratio: 1 / 1; /* Makes the grid square */
        }

        .cell {
            background-color: #e8ecf1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s, transform 0.1s;
            height: 100%;
            min-height: 80px; /* Minimum height for mobile */
            user-select: none;
            text-align: center;
            padding: 5px;
        }

        .cell:hover:not(.definite):not(.selected-cell) {
            background-color: #dce0e6;
        }

        .cell.selected-cell {
            background-color: #6366f1;
            color: white;
            transform: scale(1.05);
        }

        .cell.definite {
            cursor: default;
            background-color: #3b82f6; /* Blue for definite */
            color: white;
            font-size: 3rem;
        }
        
        /* Style for quantum moves inside the cell */
        .q-move-text {
            font-size: 0.85rem;
            font-weight: 400;
            color: #6b7280;
            line-height: 1.2;
            margin-top: 2px;
        }

        .definite .q-move-text {
            display: none;
        }
        
        .x-player { color: #ef4444; } /* Red */
        .o-player { color: #10b981; } /* Green */
        .collapse-mode { background-color: #fca5a5; } /* Light red for collapse */

        /* Style for buttons and messages */
        .btn-primary {
            background-color: #10b981;
            color: white;
            padding: 10px 20px;
            border-radius: 0.5rem;
            font-weight: 700;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: #059669;
        }

        .message-box {
            min-height: 60px;
        }
        
        /* Collapse buttons */
        .collapse-option {
            background-color: #fef3c7;
            border: 2px solid #f59e0b;
            color: #f59e0b;
            font-weight: 600;
            padding: 8px 15px;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .collapse-option:hover {
            background-color: #fffbeb;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-4 text-gray-800">Κβαντική Τρίλιζα</h1>
        <p class="text-center text-gray-600 mb-6">Στόχος: Δημιουργία τριών οριστικών X ή O στη σειρά μετά από μια κατάρρευση.</p>

        <div id="message" class="message-box text-center p-3 mb-4 rounded-lg font-bold text-lg"></div>

        <div id="board" class="board border-4 border-gray-400 rounded-lg"></div>

        <div class="flex justify-center mt-6">
            <button id="reset-btn" class="btn-primary">
                Επανεκκίνηση Παιχνιδιού
            </button>
        </div>
        
        <div id="collapse-options" class="flex flex-wrap justify-center gap-2 mt-4"></div>
    </div>

    <script type="text/javascript">
        // Global game variables
        let gameActive = true;
        let currentPlayer = 'X';
        let moveStage = 1; // 1: Select 1st cell, 2: Select 2nd cell, 3: Collapse
        let firstCellIndex = null;
        let moveCounter = 1;
        let collapsingPlayer = null; // ποιος επιλέγει την κατάρρευση στην collapse phase
        
        // Board states:
        // definite: The definite mark ('X', 'O', or null)
        // superposition: An array with the IDs of the quantum moves involved in this cell.
        let boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));

        // Records all quantum moves
        // Example: { id: 1, player: 'X', cells: [0, 4] }
        let superpositionMoves = []; 

        const winningCombos = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Horizontal
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Vertical
            [0, 4, 8], [2, 4, 6]            // Diagonal
        ];

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const resetBtn = document.getElementById('reset-btn');
        const collapseOptionsElement = document.getElementById('collapse-options');

        // --- Helper Functions ---

        /**
         * Updates the game status message.
         */
        function updateMessage(text, colorClass = 'text-gray-800', backgroundClass = 'bg-gray-200') {
            messageElement.textContent = text;
            messageElement.className = `message-box text-center p-3 mb-4 rounded-lg font-bold text-lg ${colorClass} ${backgroundClass}`;
        }

        /**
         * Renders the board state to the DOM.
         */
        function renderBoard() {
            boardElement.innerHTML = '';
            boardState.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.dataset.index = index;

                if (cell.definite) {
                    // Definite state
                    cellElement.classList.add('definite');
                    cellElement.textContent = cell.definite;
                    cellElement.classList.add(cell.definite === 'X' ? 'x-player' : 'o-player');
                } else {
                    // Superposition
                    // Only allow clicks if not in collapse phase
                    if (moveStage !== 3 && gameActive) {
                        cellElement.addEventListener('click', handleCellClick);
                    }
                    
                    // Display the involved quantum moves
                    const movesText = cell.superposition.map(moveId => {
                        const move = superpositionMoves.find(m => m.id === moveId);
                        if (!move) return '';
                        
                        // Greek translation in display
                        const playerMark = move.player === 'X' ? 'Χ' : 'Ο';
                        return `<span class="${move.player === 'X' ? 'x-player' : 'o-player'}">${playerMark}<sub>${moveId}</sub></span>`;
                    }).join(', ');

                    cellElement.innerHTML = `<span class="text-2xl">&nbsp;</span><div class="q-move-text">${movesText}</div>`;

                    // Display selected cell during stage 2
                    if (moveStage === 2 && index === firstCellIndex) {
                        cellElement.classList.add('selected-cell');
                    }
                }

                boardElement.appendChild(cellElement);
            });
        }
        
        /**
         * Checks for a win in the definite board state.
         */
        function checkForWin() {
            for (const [a, b, c] of winningCombos) {
                const valA = boardState[a].definite;
                const valB = boardState[b].definite;
                const valC = boardState[c].definite;

                if (valA && valA === valB && valA === valC) {
                    gameActive = false;
                    const winnerMark = valA === 'X' ? 'Χ' : 'Ο'; // Greek mark for display
                    updateMessage(`Νικητής: Παίκτης ${winnerMark}!`, 'text-white', valA === 'X' ? 'bg-red-600' : 'bg-green-600');
                    return true;
                }
            }

            // Check for tie (if all cells are definite)
            const allDefinite = boardState.every(cell => cell.definite !== null);
            if (allDefinite) {
                gameActive = false;
                updateMessage("Ισοπαλία! Ο πίνακας έχει καταρρεύσει πλήρως.", 'text-gray-800', 'bg-yellow-400');
                return true;
            }

            return false;
        }

        /**
         * Δημιουργεί τον γράφο εμπλοκής μόνο με τις ενεργές κινήσεις υπέρθεσης.
         */
        function createEntanglementGraph() {
            const nodes = 9;
            const adj = Array.from({ length: nodes }, () => []);
            
            for (const move of superpositionMoves) {
                const [u, v] = move.cells;

                const isMoveActive =
                    boardState[u].superposition.includes(move.id) &&
                    boardState[v].superposition.includes(move.id);

                if (isMoveActive) {
                    adj[u].push({ neighbor: v, moveId: move.id });
                    adj[v].push({ neighbor: u, moveId: move.id });
                }
            }
            return { adj };
        }
        
        /**
         * Detects a cycle (loop) in the superposition graph using DFS.
         * Also detects 2-cell loops (same two cells used twice).
         * @param {Object} newMove - The last quantum move added.
         */
        function findCycle(newMove) {
            // 1️⃣ Ειδικός έλεγχος: δύο κινήσεις στα ίδια δύο κελιά (2-cell loop)
            const [u, v] = newMove.cells;

            const movesInBoth = boardState[u].superposition.filter(id =>
                boardState[v].superposition.includes(id)
            );

            if (movesInBoth.length >= 2) {
                // Έχουμε βρόχο μεταξύ των δύο κελιών u–v
                return movesInBoth;
            }

            // 2️⃣ Αν δεν υπάρχει 2-cell loop, συνεχίζουμε με DFS για μεγαλύτερους κύκλους
            const { adj } = createEntanglementGraph();
            const nodes = 9;
            const visited = new Array(nodes).fill(false);
            const path = []; 
            
            function dfs(node, parentNode) { 
                visited[node] = true;
                path.push(node);

                for (const { neighbor: neigh } of adj[node]) {
                    if (neigh === parentNode) continue; 
                    
                    if (visited[neigh]) {
                        const startIndex = path.indexOf(neigh);
                        if (startIndex !== -1) {
                            let cycleMoves = [];
                            
                            for (let i = startIndex; i < path.length; i++) {
                                const cell1 = path[i];
                                const cell2 = (i === path.length - 1) ? node : path[i + 1];

                                const moveLink = superpositionMoves.find(m => 
                                    ((m.cells[0] === cell1 && m.cells[1] === cell2) || 
                                     (m.cells[0] === cell2 && m.cells[1] === cell1))
                                );
                                if (moveLink && !cycleMoves.includes(moveLink.id)) {
                                    cycleMoves.push(moveLink.id);
                                }
                            }
                            
                            const closingMove = superpositionMoves.find(m => 
                                ((m.cells[0] === node && m.cells[1] === neigh) || 
                                 (m.cells[0] === neigh && m.cells[1] === node))
                            );
                            if (closingMove && !cycleMoves.includes(closingMove.id)) {
                                cycleMoves.push(closingMove.id);
                            }
                            
                            return cycleMoves;
                        }
                    } else {
                        const result = dfs(neigh, node);
                        if (result) return result;
                    }
                }

                path.pop(); 
                return null;
            }

            for (let i = 0; i < nodes; i++) {
                if (!visited[i] && boardState[i].definite === null) {
                    const result = dfs(i, -1);
                    if (result) return result;
                }
            }
            
            return null;
        }

        /**
         * Βοηθητική: δίνει μια σειρά κορυφών και κινήσεων που σχηματίζουν τον κύκλο.
         * @param {Array<Object>} cycleMoves
         * @returns {{orderedCells:number[], orderedMoves:number[]}}
         */
        function orderCycle(cycleMoves) {
            const cellSet = new Set();
            cycleMoves.forEach(m => {
                cellSet.add(m.cells[0]);
                cellSet.add(m.cells[1]);
            });
            const cycleCells = Array.from(cellSet);

            const adj = {};
            cycleCells.forEach(c => adj[c] = []);
            cycleMoves.forEach(m => {
                const [u, v] = m.cells;
                adj[u].push({ neighbor: v, moveId: m.id });
                adj[v].push({ neighbor: u, moveId: m.id });
            });

            const start = cycleCells[0];
            let prev = null;
            let curr = start;
            const orderedCells = [start];
            const orderedMoves = [];

            while (true) {
                const neighbors = adj[curr];
                let edge = neighbors[0];
                if (prev !== null && neighbors[0].neighbor === prev) {
                    edge = neighbors[1];
                }
                const next = edge.neighbor;
                orderedMoves.push(edge.moveId);
                if (next === start) break;
                orderedCells.push(next);
                prev = curr;
                curr = next;
            }

            return { orderedCells, orderedMoves };
        }

        /**
         * Starts the collapse phase.
         * @param {Array<number>} cycleMoveIds - IDs of the moves forming the cycle.
         */
        function startCollapsePhase(cycleMoveIds) {
            gameActive = true; 
            moveStage = 3; 
            boardElement.classList.add('collapse-mode');
            
            const cycleMoves = superpositionMoves.filter(m => cycleMoveIds.includes(m.id));
            if (cycleMoves.length === 0) {
                updateMessage("Σφάλμα: Κενός κύκλος.", 'text-red-800', 'bg-red-100');
                gameActive = false;
                return;
            }

            const { orderedCells, orderedMoves } = orderCycle(cycleMoves);
            const k = orderedCells.length;

            // Δύο επιτρεπτές καταρρεύσεις: Προσανατολισμός A και B
            const assignmentA = {}; // edge i → cell i+1
            const assignmentB = {}; // edge i → cell i
            for (let i = 0; i < k; i++) {
                const moveId = orderedMoves[i];
                const cellA = orderedCells[i];
                const cellB = orderedCells[(i + 1) % k];
                assignmentA[cellB] = moveId;
                assignmentB[cellA] = moveId;
            }

            // Βρίσκουμε την τελευταία κίνηση (μεγαλύτερο id) για την περιγραφή του κουμπιού
            const lastId = Math.max(...cycleMoveIds);
            const lastMove = cycleMoves.find(m => m.id === lastId) || cycleMoves[cycleMoves.length - 1];

            const findCellForMove = (assignment, moveId) => {
                for (const [cellStr, mid] of Object.entries(assignment)) {
                    if (mid === moveId) return parseInt(cellStr, 10);
                }
                return null;
            };

            const cellA_for_last = findCellForMove(assignmentA, lastMove.id);
            const cellB_for_last = findCellForMove(assignmentB, lastMove.id);

            const movePlayerMark = lastMove.player === 'X' ? 'Χ' : 'Ο';

            updateMessage(
                `Παίκτης ${collapsingPlayer === 'X' ? 'Χ' : 'Ο'}: Επιλέξτε μία από τις δύο δυνατές καταρρεύσεις του κύκλου.`,
                'text-red-700',
                'bg-red-200'
            );

            collapseOptionsElement.innerHTML = '';

            // Επιλογή 1
            const btn1 = document.createElement('button');
            btn1.classList.add('collapse-option');
            btn1.textContent = `Επιλογή 1: ${movePlayerMark}${lastMove.id} → Κελί ${cellA_for_last + 1}`;
            btn1.onclick = () => resolveCollapse(assignmentA, orderedCells, cycleMoveIds);
            collapseOptionsElement.appendChild(btn1);

            // Επιλογή 2
            const btn2 = document.createElement('button');
            btn2.classList.add('collapse-option');
            btn2.textContent = `Επιλογή 2: ${movePlayerMark}${lastMove.id} → Κελί ${cellB_for_last + 1}`;
            btn2.onclick = () => resolveCollapse(assignmentB, orderedCells, cycleMoveIds);
            collapseOptionsElement.appendChild(btn2);

            // Απενεργοποίηση κλικ στον πίνακα μέχρι να γίνει η μέτρηση
            boardElement.querySelectorAll('.cell').forEach(cell => cell.removeEventListener('click', handleCellClick));
        }
        
        /**
         * Resolves the collapse for the chosen global assignment.
         * @param {Object} assignment - mapping: cellIndex -> moveId
         * @param {Array<number>} cycleCells - cells belonging to the cycle
         * @param {Array<number>} cycleMoveIds - move IDs in the cycle
         */
        function resolveCollapse(assignment, cycleCells, cycleMoveIds) {
            collapseOptionsElement.innerHTML = '';
            boardElement.classList.remove('collapse-mode');

            // 1. Remove all cycle moves from all superpositions
            for (let i = 0; i < 9; i++) {
                boardState[i].superposition = boardState[i].superposition.filter(
                    id => !cycleMoveIds.includes(id)
                );
            }

            // 2. Set definite marks for all cycle cells according to the chosen orientation
            for (const cellIndex of cycleCells) {
                const moveId = assignment[cellIndex];
                const move = superpositionMoves.find(m => m.id === moveId);
                if (move) {
                    boardState[cellIndex].definite = move.player;
                }
            }

            // 3. Deterministic propagation for chains hanging off the cycle
            let changed = true;
            while (changed) {
                changed = false;

                // Κανόνας 1: Οριστικά κελιά αφαιρούν τις κινήσεις τους από γειτονικά κελιά (εκτός κύκλου)
                for (let i = 0; i < 9; i++) {
                    if (boardState[i].definite !== null) {
                        for (const move of superpositionMoves) {
                            if (cycleMoveIds.includes(move.id)) continue; // παραλείπουμε τον κύκλο
                            if (move.cells.includes(i)) {
                                const other = (move.cells[0] === i) ? move.cells[1] : move.cells[0];
                                const beforeLen = boardState[other].superposition.length;
                                boardState[other].superposition =
                                    boardState[other].superposition.filter(id => id !== move.id);
                                if (boardState[other].superposition.length !== beforeLen) {
                                    changed = true;
                                }
                            }
                        }
                    }
                }

                // Κανόνας 2: Όποιο κελί έχει μία μόνο κβαντική επιλογή γίνεται οριστικό
                for (let i = 0; i < 9; i++) {
                    if (boardState[i].definite === null &&
                        boardState[i].superposition.length === 1) {
                        const winningMoveId = boardState[i].superposition[0];
                        const winningMove = superpositionMoves.find(m => m.id === winningMoveId);
                        if (winningMove) {
                            boardState[i].definite = winningMove.player;
                            boardState[i].superposition = [];
                            changed = true;
                        }
                    }
                }
            }

            // 4. Final cleanup
            for (let i = 0; i < 9; i++) {
                if (boardState[i].definite !== null) {
                    boardState[i].superposition = [];
                }
            }

            // 5. Check for win
            renderBoard();
            if (checkForWin()) return;

            // 6. Continue the game: σειρά στον άλλο παίκτη
            moveStage = 1;
            firstCellIndex = null;

            if (collapsingPlayer === 'X') {
                currentPlayer = 'O';
            } else if (collapsingPlayer === 'O') {
                currentPlayer = 'X';
            }
            collapsingPlayer = null;

            const nextPlayerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
            updateMessage(`Παίκτης ${nextPlayerMark}: Κάντε την 1η επιλογή σας.`, 'text-gray-800', 'bg-gray-200');
            renderBoard();
        }

        // --- Main Game Logic ---

        /**
         * Handles cell click.
         */
        function handleCellClick(event) {
            if (!gameActive || moveStage === 3) return;

            const index = parseInt(event.currentTarget.dataset.index);

            if (boardState[index].definite !== null) {
                updateMessage("Αυτό το κελί έχει ήδη καταρρεύσει (είναι οριστικό). Επιλέξτε άλλο.", 'text-red-600', 'bg-red-100');
                return;
            }
            
            const playerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';

            if (moveStage === 1) {
                // Stage 1: Select 1st cell
                firstCellIndex = index;
                moveStage = 2;
                updateMessage(
                    `Παίκτης ${playerMark}: Κάντε την 2η επιλογή σας. (Επιλεγμένο: Κελί ${index + 1})`,
                    'text-blue-700',
                    'bg-blue-100'
                );
                renderBoard();

            } else if (moveStage === 2) {
                // Stage 2: Select 2nd cell
                if (index === firstCellIndex) {
                    updateMessage("Πρέπει να επιλέξετε ένα διαφορετικό κελί.", 'text-red-600', 'bg-red-100');
                    return;
                }

                // Create new quantum move
                const newMove = { 
                    id: moveCounter, 
                    player: currentPlayer, 
                    cells: [firstCellIndex, index] 
                };

                // Add the move to the board state
                superpositionMoves.push(newMove);
                boardState[firstCellIndex].superposition.push(newMove.id);
                boardState[index].superposition.push(newMove.id);

                // Check for cycle (Collapse)
                const cycle = findCycle(newMove);
                
                if (cycle && cycle.length > 0) {
                    // Ο παίκτης που έκλεισε τον κύκλο έκανε την τελευταία κίνηση,
                    // άρα ο ΑΛΛΟΣ παίκτης επιλέγει την κατάρρευση (κανόνας QT3)
                    collapsingPlayer = (currentPlayer === 'X') ? 'O' : 'X';

                    moveCounter++;
                    startCollapsePhase(cycle);
                } else {
                    // No collapse. Continue game.
                    moveCounter++;
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    moveStage = 1;
                    firstCellIndex = null;
                    const nextPlayerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
                    updateMessage(
                        `Παίκτης ${nextPlayerMark}: Κάντε την 1η επιλογή σας.`,
                        'text-gray-800',
                        'bg-gray-200'
                    );
                }

                renderBoard();
            }
        }

        /**
         * Resets the game to its initial state.
         */
        function resetGame() {
            gameActive = true;
            currentPlayer = 'X';
            moveStage = 1;
            firstCellIndex = null;
            moveCounter = 1;
            collapsingPlayer = null;
            boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));
            superpositionMoves = [];
            collapseOptionsElement.innerHTML = '';
            boardElement.classList.remove('collapse-mode');
            
            const playerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
            updateMessage(`Παίκτης ${playerMark}: Κάντε την 1η επιλογή σας.`, 'text-gray-800', 'bg-gray-200');
            renderBoard();
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            resetBtn.addEventListener('click', resetGame);
            resetGame(); // Start the game
        });
    </script>
</body>
</html>

