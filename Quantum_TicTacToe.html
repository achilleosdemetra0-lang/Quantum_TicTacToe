<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Κβαντική Τρίλιζα</title>
    <!-- Φόρτωση Tailwind CSS για βασικό στυλ και ευκολία -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f7f9fb;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            margin: 20px 0;
            aspect-ratio: 1 / 1; /* Makes the grid square */
        }

        .cell {
            background-color: #e8ecf1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s, transform 0.1s;
            height: 100%;
            min-height: 80px; /* Minimum height for mobile */
            user-select: none;
            text-align: center;
            padding: 5px;
        }

        .cell:hover:not(.definite):not(.selected-cell) {
            background-color: #dce0e6;
        }

        .cell.selected-cell {
            background-color: #6366f1;
            color: white;
            transform: scale(1.05);
        }

        .cell.definite {
            cursor: default;
            background-color: #3b82f6; /* Blue for definite */
            color: white;
            font-size: 3rem;
        }
        
        /* Style for quantum moves inside the cell */
        .q-move-text {
            font-size: 0.85rem;
            font-weight: 400;
            color: #6b7280;
            line-height: 1.2;
            margin-top: 2px;
        }

        .definite .q-move-text {
            display: none;
        }
        
        .x-player { color: #ef4444; } /* Red */
        .o-player { color: #10b981; } /* Green */
        .collapse-mode { background-color: #fca5a5; } /* Light red for collapse */

        /* Style for buttons and messages */
        .btn-primary {
            background-color: #10b981;
            color: white;
            padding: 10px 20px;
            border-radius: 0.5rem;
            font-weight: 700;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: #059669;
        }

        .message-box {
            min-height: 60px;
        }
        
        /* Collapse buttons */
        .collapse-option {
            background-color: #fef3c7;
            border: 2px solid #f59e0b;
            color: #f59e0b;
            font-weight: 600;
            padding: 8px 15px;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .collapse-option:hover {
            background-color: #fffbeb;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-4 text-gray-800">Κβαντική Τρίλιζα</h1>
        <p class="text-center text-gray-600 mb-6">Στόχος: Δημιουργία τριών οριστικών X ή O στη σειρά μετά από μια κατάρρευση.</p>

        <!-- Μηνύματα κατάστασης παιχνιδιού -->
        <div id="message" class="message-box text-center p-3 mb-4 rounded-lg font-bold text-lg"></div>

        <!-- Πίνακας παιχνιδιού -->
        <div id="board" class="board border-4 border-gray-400 rounded-lg">
            <!-- Cells will be generated by JavaScript -->
        </div>

        <div class="flex justify-center mt-6">
            <button id="reset-btn" class="btn-primary">
                Επανεκκίνηση Παιχνιδιού
            </button>
        </div>
        
        <!-- Area for collapse options -->
        <div id="collapse-options" class="flex flex-wrap justify-center gap-2 mt-4">
            <!-- Options will appear during the collapse phase -->
        </div>
    </div>

    <script type="text/javascript">
        // Global game variables
        let gameActive = true;
        let currentPlayer = 'X';
        let moveStage = 1; // 1: Select 1st cell, 2: Select 2nd cell, 3: Collapse
        let firstCellIndex = null;
        let moveCounter = 1;
        
        // Board states:
        // definite: The definite mark ('X', 'O', or null)
        // superposition: An array with the IDs of the quantum moves involved in this cell.
        let boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));

        // Records all quantum moves
        // Example: { id: 1, player: 'X', cells: [0, 4] }
        let superpositionMoves = []; 

        const winningCombos = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Horizontal
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Vertical
            [0, 4, 8], [2, 4, 6]             // Diagonal
        ];

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const resetBtn = document.getElementById('reset-btn');
        const collapseOptionsElement = document.getElementById('collapse-options');

        // --- Helper Functions ---

        /**
         * Updates the game status message.
         */
        function updateMessage(text, colorClass = 'text-gray-800', backgroundClass = 'bg-gray-200') {
            messageElement.textContent = text;
            messageElement.className = `message-box text-center p-3 mb-4 rounded-lg font-bold text-lg ${colorClass} ${backgroundClass}`;
        }

        /**
         * Renders the board state to the DOM.
         */
        function renderBoard() {
            boardElement.innerHTML = '';
            boardState.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.dataset.index = index;

                if (cell.definite) {
                    // Definite state
                    cellElement.classList.add('definite');
                    cellElement.textContent = cell.definite;
                    cellElement.classList.add(cell.definite === 'X' ? 'x-player' : 'o-player');
                } else {
                    // Superposition
                    cellElement.addEventListener('click', handleCellClick);
                    
                    // Display the involved quantum moves
                    const movesText = cell.superposition.map(moveId => {
                        const move = superpositionMoves.find(m => m.id === moveId);
                        // Greek translation in display
                        const playerMark = move.player === 'X' ? 'Χ' : 'Ο';
                        return `<span class="${move.player === 'X' ? 'x-player' : 'o-player'}">${playerMark}<sub>${moveId}</sub></span>`;
                    }).join(', ');

                    cellElement.innerHTML = `<span class="text-2xl">&nbsp;</span><div class="q-move-text">${movesText}</div>`;

                    // Display selected cell during stage 1
                    if (moveStage === 2 && index === firstCellIndex) {
                        cellElement.classList.add('selected-cell');
                    }
                }

                boardElement.appendChild(cellElement);
            });
        }
        
        /**
         * Checks for a win in the definite board state.
         */
        function checkForWin() {
            for (const [a, b, c] of winningCombos) {
                const valA = boardState[a].definite;
                const valB = boardState[b].definite;
                const valC = boardState[c].definite;

                if (valA && valA === valB && valA === valC) {
                    gameActive = false;
                    const winnerMark = valA === 'X' ? 'Χ' : 'Ο'; // Greek mark for display
                    updateMessage(`Νικητής: Παίκτης ${winnerMark}!`, 'text-white', valA === 'X' ? 'bg-red-600' : 'bg-green-600');
                    return true;
                }
            }

            // Check for tie (if all cells are definite)
            const allDefinite = boardState.every(cell => cell.definite !== null);
            if (allDefinite) {
                gameActive = false;
                updateMessage("Ισοπαλία! Ο πίνακας έχει καταρρεύσει πλήρως.", 'text-gray-800', 'bg-yellow-400');
                return true;
            }

            return false;
        }

        /**
         * Creates the entanglement graph from the quantum moves.
         */
        function createEntanglementGraph() {
            const nodes = 9;
            const adj = Array.from({ length: nodes }, () => []);
            const moveMap = {}; 

            for (const move of superpositionMoves) {
                const [u, v] = move.cells;
                adj[u].push({ neighbor: v, moveId: move.id });
                adj[v].push({ neighbor: u, moveId: move.id });
                moveMap[`${Math.min(u, v)}-${Math.max(u, v)}`] = move.id;
            }
            return { adj, moveMap };
        }
        
        /**
         * Detects a cycle (loop) in the superposition graph using DFS.
         */
        function findCycle(newMove) {
            const { adj } = createEntanglementGraph();
            const nodes = 9;
            const visited = new Array(nodes).fill(false);
            const path = []; 
            const cycle = []; 

            // DFS utility function
            function dfs(u, parentMoveId) {
                visited[u] = true;
                path.push(u);

                for (const { neighbor: v, moveId } of adj[u]) {
                    if (moveId === parentMoveId) continue; 

                    if (visited[v]) {
                        // Cycle found
                        const startIndex = path.indexOf(v);
                        if (startIndex !== -1) {
                            // Construct the cycle from the path
                            let cycleMoves = [];
                            
                            // Reconstruct the cycle backwards
                            for (let i = path.length - 1; i >= startIndex; i--) {
                                const fromNode = path[i];
                                const toNode = i < path.length - 1 ? path[i+1] : u;
                                
                                // Find the move ID between the two nodes
                                const moveLink = superpositionMoves.find(m => 
                                    (m.cells[0] === fromNode && m.cells[1] === toNode) || 
                                    (m.cells[0] === toNode && m.cells[1] === fromNode)
                                );
                                if (moveLink && !cycleMoves.includes(moveLink.id)) {
                                    cycleMoves.push(moveLink.id);
                                }
                                if (fromNode === v && i !== path.length - 1) break; 
                            }

                            // Add the move that closed the cycle (if not already included)
                            const closingMove = superpositionMoves.find(m => 
                                (m.cells[0] === u && m.cells[1] === v) || 
                                (m.cells[0] === v && m.cells[1] === u)
                            );
                            if (closingMove && !cycleMoves.includes(closingMove.id)) {
                                cycleMoves.push(closingMove.id);
                            }

                            return cycleMoves; // Returns the move IDs of the cycle
                        }
                    } else {
                        const result = dfs(v, moveId);
                        if (result) return result;
                    }
                }

                path.pop(); 
                return null;
            }

            // Start DFS from the first node of the new move
            if (newMove) {
                for (let i = 0; i < nodes; i++) {
                    if (!visited[i]) {
                        const result = dfs(i, -1);
                        if (result) return result;
                    }
                }
            }
            
            return null;
        }

        /**
         * Starts the collapse phase.
         * @param {Array<number>} cycleMoveIds - IDs of the moves forming the cycle.
         */
        function startCollapsePhase(cycleMoveIds) {
            gameActive = true; 
            moveStage = 3; 
            boardElement.classList.add('collapse-mode');
            
            // Find the moves involved in the cycle
            const cycleMoves = superpositionMoves.filter(m => cycleMoveIds.includes(m.id));
            
            // The player who made the last move chooses
            const collapsingPlayer = currentPlayer; 
            const playerMark = collapsingPlayer === 'X' ? 'Χ' : 'Ο';
            
            // The message asks the player to choose where to collapse
            updateMessage(
                `Παίκτης ${playerMark}: Επιλέξτε πού θα καταρρεύσει μια κίνηση του κύκλου.`, 
                'text-red-700', 
                'bg-red-200'
            );

            collapseOptionsElement.innerHTML = '';
            
            // Display options for all moves in the cycle
            cycleMoves.forEach(move => {
                // The move must collapse into one of its two cells
                const [cellA, cellB] = move.cells;
                const movePlayerMark = move.player === 'X' ? 'Χ' : 'Ο';
                
                // Create button for collapse to Cell A
                const btnA = document.createElement('button');
                btnA.classList.add('collapse-option');
                btnA.textContent = `${movePlayerMark}${move.id} → Κελί ${cellA + 1}`;
                btnA.onclick = () => resolveCollapse(move.id, cellA, cycleMoveIds);
                collapseOptionsElement.appendChild(btnA);

                // Create button for collapse to Cell B
                const btnB = document.createElement('button');
                btnB.classList.add('collapse-option');
                btnB.textContent = `${movePlayerMark}${move.id} → Κελί ${cellB + 1}`;
                btnB.onclick = () => resolveCollapse(move.id, cellB, cycleMoveIds);
                collapseOptionsElement.appendChild(btnB);
            });
            
            // Disable clicks on the board until measurement is done
            boardElement.querySelectorAll('.cell').forEach(cell => cell.removeEventListener('click', handleCellClick));
        }
        
        /**
         * Resolves the collapse based on the player's choice.
         * @param {number} chosenMoveId - ID of the move chosen to collapse.
         * @param {number} chosenCellIndex - The index of the cell where the move collapses.
         * @param {Array<number>} cycleMoveIds - IDs of the cycle moves.
         */
        function resolveCollapse(chosenMoveId, chosenCellIndex, cycleMoveIds) {
            collapseOptionsElement.innerHTML = '';
            boardElement.classList.remove('collapse-mode');

            // 1. Collapse the chosen move
            const chosenMove = superpositionMoves.find(m => m.id === chosenMoveId);
            const otherCellIndex = chosenMove.cells.find(i => i !== chosenCellIndex);

            // Definite placement of the mark in chosenCellIndex
            boardState[chosenCellIndex].definite = chosenMove.player;
            boardState[chosenCellIndex].superposition = boardState[chosenCellIndex].superposition.filter(id => id !== chosenMoveId);
            
            // Remove the move from the other cell
            boardState[otherCellIndex].superposition = boardState[otherCellIndex].superposition.filter(id => id !== chosenMoveId);
            
            // 2. Deterministic Collapse of the remaining moves in the cycle
            // Deterministic collapse means that all other cells in the cycle 
            // must collapse to avoid conflicts with the already definite mark.
            
            // Filter to only include moves in the cycle that have not yet collapsed
            const remainingCycleMoves = superpositionMoves.filter(m => 
                cycleMoveIds.includes(m.id) && m.id !== chosenMoveId
            );

            // Re-evaluate the board state after the first collapse
            let definiteCellsAfterFirstCollapse = new Set(boardState.map((c, i) => c.definite !== null ? i : -1).filter(i => i !== -1));

            remainingCycleMoves.forEach(move => {
                const [cell1, cell2] = move.cells;
                
                let collapseTo = null;
                
                // If one of the cells is now definite, the move must collapse to the other cell.
                const isCell1Definite = definiteCellsAfterFirstCollapse.has(cell1);
                const isCell2Definite = definiteCellsAfterFirstCollapse.has(cell2);

                if (isCell1Definite && !isCell2Definite && boardState[cell2].definite === null) {
                    collapseTo = cell2;
                } else if (isCell2Definite && !isCell1Definite && boardState[cell1].definite === null) {
                    collapseTo = cell1;
                }
                
                // If the collapse is determined and the target cell is free
                if (collapseTo !== null && boardState[collapseTo].definite === null) {
                    boardState[collapseTo].definite = move.player;
                    
                    // Update definite cells set for the next iteration if needed
                    definiteCellsAfterFirstCollapse.add(collapseTo);
                } else if (!isCell1Definite && !isCell2Definite) {
                    // For the remaining moves not deterministically forced, a simplified QTTT rule might
                    // force a collapse based on a cycle order, but for simplicity here,
                    // we'll primarily rely on the first collapse and conflicts.
                    // If no conflict, we can arbitrarily choose one, but that deviates from strict QTTT rules.
                    // Sticking to strict conflict resolution: 
                    // If both are still non-definite, the state remains complex. 
                    // To simplify and ensure determinism *after* the initial choice:
                    // If the other cell of the chosen move is NOT definite, the current move collapses to avoid it.
                    // For now, we rely on the conflict resolution above.
                }
            });
            
            // 3. Cleanup: Remove resolved move IDs from all superposition lists
            const resolvedMoveIds = new Set([chosenMoveId, ...remainingCycleMoves.map(m => m.id)]);

            for (let i = 0; i < 9; i++) {
                if (boardState[i].definite !== null) {
                    // If definite, clear all superpositions
                    boardState[i].superposition = [];
                } else {
                    // If still superposition, remove only the resolved move IDs
                    boardState[i].superposition = boardState[i].superposition.filter(id => !resolvedMoveIds.has(id));
                }
            }


            // 4. Check for win
            renderBoard();
            if (checkForWin()) return;

            // 5. Continue the game
            moveStage = 1;
            firstCellIndex = null;
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            const nextPlayerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
            updateMessage(`Παίκτης ${nextPlayerMark}: Κάντε την 1η επιλογή σας.`, currentPlayer === 'X' ? 'x-player' : 'o-player', 'bg-gray-200');
            renderBoard();
        }


        // --- Main Game Logic ---

        /**
         * Handles cell click.
         * @param {Event} event - The click event.
         */
        function handleCellClick(event) {
            if (!gameActive || moveStage === 3) return;

            const index = parseInt(event.currentTarget.dataset.index);

            // Check if the cell is already definite
            if (boardState[index].definite !== null) {
                updateMessage("Αυτό το κελί έχει ήδη καταρρεύσει (είναι οριστικό). Επιλέξτε άλλο.", 'text-red-600', 'bg-red-100');
                return;
            }
            
            const playerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';

            if (moveStage === 1) {
                // Stage 1: Select 1st cell
                firstCellIndex = index;
                moveStage = 2;
                updateMessage(`Παίκτης ${playerMark}: Κάντε την 2η επιλογή σας. (Επιλεγμένο: Κελί ${index + 1})`, currentPlayer === 'X' ? 'x-player' : 'o-player', 'bg-blue-100');
                renderBoard();

            } else if (moveStage === 2) {
                // Stage 2: Select 2nd cell
                if (index === firstCellIndex) {
                    updateMessage("Πρέπει να επιλέξετε ένα διαφορετικό κελί.", 'text-red-600', 'bg-red-100');
                    return;
                }

                // Create new quantum move
                const newMove = { 
                    id: moveCounter, 
                    player: currentPlayer, 
                    cells: [firstCellIndex, index] 
                };

                // Add the move to the board state
                superpositionMoves.push(newMove);
                boardState[firstCellIndex].superposition.push(newMove.id);
                boardState[index].superposition.push(newMove.id);

                // Check for cycle (Collapse)
                const cycle = findCycle(newMove);
                
                if (cycle) {
                    // Collapse!
                    startCollapsePhase(cycle);
                } else {
                    // No collapse. Continue game.
                    moveCounter++;
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    moveStage = 1;
                    firstCellIndex = null;
                    const nextPlayerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
                    updateMessage(`Παίκτης ${nextPlayerMark}: Κάντε την 1η επιλογή σας.`, currentPlayer === 'X' ? 'x-player' : 'o-player', 'bg-gray-200');
                }

                renderBoard();
            }
        }

        /**
         * Resets the game to its initial state.
         */
        function resetGame() {
            gameActive = true;
            currentPlayer = 'X';
            moveStage = 1;
            firstCellIndex = null;
            moveCounter = 1;
            boardState = Array(9).fill(null).map(() => ({ definite: null, superposition: [] }));
            superpositionMoves = [];
            collapseOptionsElement.innerHTML = '';
            boardElement.classList.remove('collapse-mode');
            
            const playerMark = currentPlayer === 'X' ? 'Χ' : 'Ο';
            updateMessage(`Παίκτης ${playerMark}: Κάντε την 1η επιλογή σας.`, 'x-player', 'bg-gray-200');
            renderBoard();
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            resetBtn.addEventListener('click', resetGame);
            resetGame(); // Start the game
        });

    </script>
</body>
</html>